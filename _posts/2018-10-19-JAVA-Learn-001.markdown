---
layout:     post
title:      "JAVA语法笔记"
subtitle:   "JAVA语法备查"
date:       2018-10-19
author:     "kikyoar"
header-img: "img/post-bg-Java-version.jpg"
tags:
    - JAVA
--- 

## Java基本的程序设计结构


	public class FirstSample{
	    public static void main(String[] args){
	        System.out.println(Hello! I’m wdxtub”);
	    }
	}
	
这就是一个最简单的Java应用程序，但是所有的Java应用程序都具有这种结构

Java对**大小写**敏感。关键字**public**称为访问修饰符(access modifier)，用于控制程序的其他部分对这段代码的访问级别

**类**是构建所有Java应用程序和applet的构建块。Java应用程序中的全部内容都必须放置在类中。关键字class后面紧跟类名。Java中定义类名的规则很宽松。名字必须以字母开头，后面可以跟字母和数字的任意组合。长度基本上没有限制。但是不能使用Java的保留字

**源代码的文件名必须与公有类的名字相同，并用.java作为扩展名**

运行编译程序时，Java 虚拟机将从指定类中的main方法开始执行，并且main方法必须声明为**public**

注释有三种方法：

- // 单行的注释，内容从 // 开始到本行结尾
- /*...*/ 长篇的注释
- /**...*/ 用于自动生成文档

------------

Java是一种强类型语言。这就意味着必须为每一个变量声明一种类型。Java中一共有8种基本类型(primitive type)。其中4种整型，2种浮点类型，1种char型，1种boolean类型

整型表示没有小数部分的数值，可以是复数。分别为int(4字节)，short(2字节)，long(8字节)，byte(1字节)。由于Java程序必须保证在所有机器都能得到相同的运行结果，所以每一种数据类型的取值范围必须固定

浮点类型用于表示有小数部分的数值。分别是float(4字节，有效位数6～7位)，double(8字节，有效位数15位)

double表示这种类型的数值精度是float的两倍。绝大部分程序都采用double类型。float类型的数值有一个后缀F，没有后缀F的浮点数值默认为double类型

三个特殊的浮点数值：  

- 正无穷大
- 负无穷大
- NaN(不是一个数字，Not a Number)  

char类型用于表示单个字符。通常用来表示字符常量

**强烈建议不要在程序中使用char类型，除非确实需要对UTF-16代码单元进行操作。最好将需要处理的字符串用抽象数据类型表示**

boolean(布尔)类型有两个值：false和true，用来判定逻辑条件。整型和布尔值之间不能进行相互转换  

	/**
	 * byte:-128~127
	 * short:-32768~32767
	 * int:-2(31)~2(31)-1
	 * long
	 * float:单精度
	 * double:双精度
	 * char:0~655535
	 * boolean:true,false
	 */

------------   

每一个变量属于一种类型(type)。声明变量时，变量所属的类型位于变量名之前，每个声明以分号结束 

可以在一行中声明多个变量，不过不提倡使用这种风格。逐一声明每一个变量可以提高程序的可读性

**声明一个变量之后，必须用赋值语句对变量进行显式的初始化**，千万不要使用未被初始化的变量。可以将声明放在代码中的任何地方，变量的声明应尽可能地靠近变量第一次使用的地方

利用关键字**final**声明常量，表示这个变量只能被赋值一次。一旦被赋值后就不能再更改了。习惯上，常量名使用大写

若希望某个常量可以在一个类中的多个方法中使用，通常将这些常量称为类常量，使用**static final**设置。类常量的定义位于main方法的外部，所以在同一个类的其他方法中也可以使用这个常量  


------------   

## 运算符  

Java程序设计语言承认了最优性能与理想结果之间存在的冲突，并给予了改进。在默认情况下，虚拟机设计者允许中间结果采用拓展的精度。但对于**strictfp**关键字标记的方法必须使用严格的浮点计算来产生理想的结果

自增运算符与自减运算符 前缀方式先进行加一或减一的运算，后缀方式则使用变量原来的值。建议不要在其他表达式的内部使用++，使人迷惑，产生bug

关系运算符与boolean运算符，其中==，!=，<，>，<=，>=，||，&&均与C++一致

位运算符

- &(与)，|(或)，^(异或)，-(非)
- \>>和<<运算符进行右移或左移操作，屏蔽某些位。
- \>>>运算符用0填充高位；>>运算符用符号填充高位，没有<<<运算符

在Math类中，包含各种的数学函数。若得到一个完全可预测的结果比运行速度更重要的话，就应该使用StrictMath类  

	// 运算俩边是同类型才可以进行预算
	/**
	 * 二进制和生活中文字的对应关系编码表----美国信息标准交换码（ASCII）
	 * 01100001----a
	 * 01100010----b
	 *
	 */
	
	
	/**
	 * byte b = 4;
	 * byte b1 = 5;
	 * byte b2 = 6;
	 * b = b1 + b2;    //会报错，主要原因是b1和b2是变量，不确定值，所以会报错，但是如果是int，则会正常输出，因为整数基本都是int，默认类型
	 * 但是如果超过Integer.MAX_VALUE,则为负值
	 */  

**整型转换为float或double型很有可能损失精度**  

在圆括号中给出想要转换的目标类型，后面紧跟待转换的变量名，如

	double x = 9.998;
	int nx = (int)x;
	
若想进行四舍五入计算，使用 Math.round 方法

括号与运算符级别与正常情况下一致。少数结合性是从右向左的  

枚举类型包括有限个命名的值

如 `enum Size{SMALL,MEDIUM,LARGE,EXTRA_LARGE}`

Java字符串就是Unicode字符序列

String类的substring方法可以从一个较大的字符串提取一个子串，容易计算子串长度，语句：s.substring(a,b)，长度即为b-a

**允许使用+号连接(拼接)两个字符串**

String类没有提供用于修改字符串的方法，所以在Java文档中将String类对象称为不可变字符串

不可变字符又一个优点：编译器可以让字符串共享。Java的设计者认为共享带来的高效率远远胜过于提取

**使用equals方法检测两个字符串是否相等**。s.equals(t)，若 s 与 t 相等，则返回true，否则返回false。s 和 t 可以是字符串变量也可以是字符串常量，如”Hello”.equals(greeting)

如果不区分大小写，使用equalsIgnoreCase方法。**一定不能使用 == 运算符检测两个字符串是否相等**！这个运算符只能够确定两个字符是否放置在同一个位置上。

大多数的常用Unicode字符使用一个代码单元就可以表示，而辅助字符则需要一对代码来表示。

s.charAt(n)将返回位置 n 的代码单元，n介于0～s.length()-1之间。对于那些一对代码单元表示的字符，就会出现问题。而codePointAt可以解决这个问题

**java.lang.string**  

- char charAt( int index ) 返回给定位置的代码单元。除非对底层的代码单元感兴趣，否则不需要调用这个方法  		
- int codePointAt( int index )  返回从给定位置开始或结束的代码点  
- int offsetByCodePoints( int startIndex, int cpCount ) 返回从 startIndex 代码点开始，位移 cpCount 后的代码点索引 
- int compareTo( String other )
按照字典顺序，如果字符串位于other之前，返回一个负数；位于other之后，返回一个正数；如果两个字符串相等，返回0。
- boolean endsWith( String suffix )
如果字符串以suffix结尾，返回true。
- boolean equals( Object other )
如果字符串以other相等，返回true。
- boolean equalsIgnoreCase( String other )
如果字符串与other相等(忽略大小写)，返回true。

		int indexOf( String str )
		int indexOf( String, int fromIndex )
		int indexOf( int cp )
		int indexOf( int cp, int fromIndex )
	返回与字符串str或代码点cp匹配的第一个子串的开始位置。这个位置从索引0或fromIndex开始计算。如果在原始串中不存在str，返回-1  
		
		int lastIndexOf( String str )
		int lastIndexOf( String str, int fromIndex )
		int lastIndexOf( int cp )
		int lastIndexOf( int cp, int fromIndex )
	返回与字符串str或代码点cp匹配的最后一个子串的开始位置。这个位置从原始串尾端或fromIndex开始计算

- int length() 返回字符串的长度
- int codePointCount( int startIndex, int endIndex) 返回startIndex和endIndex-1之间的代码点数量。没有配成对的代用字符将计入代码点
- String replace(CharSequence oldString, CharSequence newString)
返回一个新字符串。这个字符串用newString代替原始字符串中的所有oldString。可以用String或StringBuilder对象作为CharSequence参数  
- boolean startsWith( String prefix ) 如果字符串以prefix字符串开始，返回true  

		String substring( int beginIndex ) 
		String substring( int beginIndex, int endIndex )
	返回一个新字符串。这个字符串包含原始字符串中从beginIndex到串尾或endIndex-1的所有代码点
- String toLowerCase() 返回一个新字符串，这个字符串将原始字符串中的所有大写字母改成了小写字母
- String toUpperCase() 返回一个新字符串，这个字符串将原始字符串中的所有小写字母改成了大写字母  
- String trim()  返回一个新字符串。这个字符串将山除了原始字符串头部和尾部的空格

如果需要用许多小段的字符串构建一个字符串，那么应该按照下列步骤进行。首先，构建一个空的字符串构建器：

	StringBuilder builder = new StringBuilder();

当每次需要添加一部分内容时，就调用append方法。

	builder.append(ch); // appends a single character
	builder.append(str);    // appends a string  

**java.lang.StringBuilder**	

- StringBuilder() 构造一个空的字符串构建器
- int length() 返回构建器或缓冲器中的代码单元数量
- StringBuilder append( String str ) 追加一个字符串并返回this 
- StringBuilder append( char c ) 追加一个代码单元并返回this
- StringBuilder appendCodePoint( int cp ) 追加一个代码点，并将其转换为一个或两个代码单元并返回this
- void setCharAt( int i,char c ) 将第 i 个代码单元设置为 c
- StringBuilder insert( int offset,String str ) 在offset位置插入一个字符串并返回this
- StringBuilder insert( int offset,Char c ) 在offset位置插入一个代码单元并返回this
- StringBuilder delete( int startIndex,int endIndex ) 删除偏移量从startIndex到-endIndex-1的代码单元并返回this
- String toString() 返回一个与构建器或缓冲器内容相同的字符串

[转载](https://wdxtub.com/2016/03/20/java-note/)
	

