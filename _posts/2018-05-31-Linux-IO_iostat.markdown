---
layout:     post
title:      "Linux磁盘I/O性能监控——iostat"
subtitle:   "块I/O层概念详见"
date:       2018-05-31
author:     "kikyoar"
header-img: "img/post-bg-linux-version.jpg"
tags:
    - Linux
---   

## 块I/O层详解   

**块I/O层是Linux内核的一个子系统，其作用是对块设备和块设备的请求进行管理**   

**块设备**   
系统中能够随机访问固定大小数据片的硬件设备。常见的块设备是硬盘  

**块**  
固定大小的数据片称之为块  

**字符设备**  
另一种基本类型设备字符设备。字符设备按照字符流被有序访问。常见的如键盘  
区别块设备与字符设备，就看该设备访问数据是随机访问还是顺序方位，如果是随机访问，则是块设备；如果是顺序访问，则是字符设备    

**块设备**   
块设备中最小的可寻址单元是扇区。如磁盘扇区的大小一般是512字节   
软件的最小逻辑可寻址单元是块。物理磁盘寻址是按照扇区进行的，但是Linux内核执行的所有磁盘操作都是通过块进行的，块是文件系统的最小寻址单元。块是文件系统的一种抽象，只能基于块来访问文件系统；扇区是设备的最小寻址单元，块是扇区大小的2的整数倍，但是比一个物理页长度小。关于块和扇区的总结如下：   

- 扇区——设备（如磁盘）的最小寻址单元 
- 块——文件系统的最小寻址单元，又称为文件块或者I/O块  

**缓冲区和缓冲头**   

- 缓冲区：buffer,存放块的区域。注意，这个缓冲区指的是磁盘缓冲区，而不是一些应用程序的缓冲区。当一个块被调入内存时（读入后或者等待写出时），块需要存储在一个缓冲区里面。每个缓冲区与一个块对应，缓冲区相当于磁盘块在内存中的表示（磁盘块到页的映射）。因为一个块比页小，所以一个页中可以容纳一个或多个内存中的块。 

- 缓冲头：存放内核处理数据时需要的一些相关信息的结构描述符（如块属于哪一个设备，块对应的是哪个缓冲区）。该描述符用buffer_head表示，称为缓冲头。buffer_header结构体中有一个域为：b_state。b_state域表示的缓冲区的状态。其中有一个标志是:BH_Dirty，这个标志表示缓冲区是脏的（缓存中的内容比磁盘中的新），所以缓冲区内容必须被写回磁盘。

**请求队列**  

块设备将它们挂起的块I/O请求保存在请求队列中。请求是由内核（文件系统提交请求到请求队列）将其加入请求队列的，只要请求队列不为空，队列对应的块设备的驱动程序就会从队列头获取请求，然后将其送到对应的块设备上去。   

**I/O调度程序**  

I/O调度程序：在内核中，负责提交I/O请求的子系统称为I/O调度程序   
磁盘寻址是整个计算机中最慢的操作之一了。因此，如果直接从队列中顺序读取并将请求发给块设备的话，性能是十分低下的。为了优化寻址操作，内核既不会简单地按请求接受顺序处理，也不会立即将请求提交给磁盘。对此，内核的做法是：请求提交之前，先执行合并与排序的预操作，这种操作会极大的提高整体性能。I/O调度程序将磁盘I/O资源分配给系统中所有挂起的块I/O请求，这种资源分配是通过将请求队列中挂起的请求合并和排序来完成的。  

**I/O调度程序工作原理**  

I/O调度程序管理的是块设备的请求队列。I/O调度程序决定了队列中的请求排序以及在什么时候派发请求到块设备。这样做降低了磁盘寻址时间，从而提高全局吞吐量。   
那么是怎么降低寻址时间的了？   
I/O调度程序是通过合并与排序完成这个目标的。因为合并会将两个块请求合并为一个请求——之所以能合并为一个请求，是因为新提交的请求和请求队列现有的请求可能刚好访问的磁盘扇区是相邻的。所以，通过合并操作，可以将这两个I/O请求合并为压缩成一次请求，寻址也只要寻一次了，这样就可以降低开销了。但是，如果请求队列中的请求不需要操作相邻扇区呢？这个时候是无法合并的。但是，我们知道，磁盘寻址是一个扇区一个扇区进行的，如果这些扇区比较接近的话，那把比较接近的扇区放在一起，这样访问起来就会更快（因为这样可以保证磁头的移动方向是线性的，而不用来回摆动。一步到位比来回寻址快多了）。所以I/O调度程序会将请求队列按扇区增长的方向排列，使所有的请求按照硬盘上扇区的顺序有序排列，减少磁头移动，缩短寻址时间。这种排序方法叫做Linus电梯   
对于Linus电梯，总结如下： 

- 合并：新提交的请求和原有请求队列中的请求访问的扇区相邻，这种情况可以合并 
- 排序：没有合并的条件，但是有多个请求访问的扇区比较接近，通过将请求排序，可以使得磁头线性工作   

## iostat  

**iostat命令可以查看CPU利用率和磁盘性能相关数据，有时候我们会觉得系统响应慢，传数据很慢，这个慢可能是多方面原因导致的，如CPU利用率高、网络差、系统平均负载高甚至是磁盘已经损坏了。对此，系统性能出问题时，磁盘I/O是一个值得重点分析的重要指标**  

**命令默认报告**  

- 默认报告CPU和磁盘的使用情况
- 以 blocks/s（块每秒）的形式报告利用率
- 默认只报告一次使用情况。可通过传参修改报告时间和次数。如：iostat 2 3，这表示每2秒报告一次，共计报告3次  

**常用选项**   

	-c    只显示CPU利用率
	-d    只显示磁盘利用率
	-p    可以报告出每块磁盘的每个分区的使用情况
	-k    以 字节/秒 为单位显示磁盘利用率报告
	-x    显示扩张统计
	-n    显示NFS（network filesystem）报告    

**各个报告结果字段含义**  

	tps    每秒I/O数（即IOPS。磁盘连续读和连续写之和）
	
	Blk_read/s    每秒从设备读取的数据大小，单位是block/s（块每秒）
	Blk_wrtn/s    每秒写入设备的数量，单位是block/s
	Blk_read    从磁盘读出的块的总数
	Blk_wrtn    写入磁盘的块的总数
	
	kB_read/s    每秒从磁盘读取数据大小，单位KB/s
	kB_wrtn/s    每秒写入磁盘的数据的大小，单位KB/s
	kB_read      从磁盘读出的数据总数，单位KB
	kB_wrtn      写入磁盘的的数据总数，单位KB
	
	rrqm/s    每秒合并到设备的读取请求数
	wrqm/s    每秒合并到设备的写请求数
	
	r/s    每秒向磁盘发起的读操作数。
	w/s    每秒向磁盘发起的写操作数。
	rsec/s    每秒从设备读取的扇区数量。
	wsec/s    每秒向设备写入的扇区数量。
	
	avgrq-sz    I/O 请求的平均大小，以扇区为单位
	avgqu-sz    向设备发起的I/O 请求队列的的平均队列长度
	
	await    I/O 请求的平均等待时间，单位为毫秒。这个时间包括请求队列（这个概念很重要）消耗的时间和为每个请求服务的时间
	svctm    I/O 请求的平均服务时间，单位为毫秒（这个数据不可信！）
	%util    处理 I/O 请求所占用的时间的百分比，即设备利用率。I/O请求期间CPU时间的百分比（即设备的带宽利用率）。当这个值接近100%时，表示磁盘I/O已经饱和  
	
**常用组合**  

	iostat -d -x
	iostat -d 2 10
	iostat -d -x 2 10
	iostat -d -x -k 2 10

命令后的第一个数字表示报告时间间隔，第二个数字表示报告总次数  

**磁盘I/O性能监控指标**  

- 磁盘吞吐量：硬盘传输数据的能力，传输数据是读、写数据之和。当传输大块不连续数据时，该值可做参考：  
	**I/O吞吐量 = IOPS * 平均I/O数据大小（size）**   
	*IOPS就是tps，即每秒I/O数；从公式可以看出，IOPS和平均数据大小越大，吞吐量则越大*   

- IOPS：磁盘每秒的I/O数（读、写之和）。当传输小块不连续数据时，该值可作为参考对象。在iostat报告中，tps=r/s+w/s  

- 数据平均大小：平均 I/O 数据大小为吞吐量除以 I/O 数目，该指标对揭示磁盘使用模式有重要意义。一般来说，如果平均 I/O 数据大小小于 32K，可认为磁盘使用模式以随机存取为主；如果平均每次 I/O 数据尺寸大于 32K，可认为磁盘使用模式以顺序存取为主  
**iostat命令输出的平均大小是以扇区为单位的，因此，转换成字节时，应该用 512 x 扇区数**  

- 磁盘活动时间比：该值对用iostat输出的%util字段，表示磁盘处于活动时间的百分比，即磁盘利用率，磁盘在数据传输和处理命令（如寻道）处于活动状态。磁盘利用率与资源争用程度成正比，与性能成反比。也就是说磁盘利用率越高，资源争用就越严重，性能也就越差，响应时间就越长。一般来说，如果磁盘利用率超过 70%，应用进程将花费较长的时间等待 I/O 完成，因为绝大多数进程在等待过程中将被阻塞或休眠  

- 服务时间：对应iostat输出的svctm。指磁盘读或写操作执行的时间，包括寻道，旋转时延，和数据传输等时间。其大小一般和磁盘性能有关，CPU / 内存的负荷也会对其有影响，请求过多也会间接导致服务时间的增加。如果该值持续超过 20ms，一般可考虑会对上层应用产生影响  

- I/O 等待队列长度：对应iostat输出的avgqu-sz。指待处理的 I/O 请求的数目，如果 I/O 请求压力持续超出磁盘处理能力，该值将增加。如果单块磁盘的队列长度持续超过 2，一般认为该磁盘存在 I/O 性能问题。需要注意的是，如果该磁盘为磁盘阵列虚拟的逻辑驱动器，需要再将该值除以组成这个逻辑驱动器的实际物理磁盘数目，以获得平均单块硬盘的 I/O 等待队列长度  

- 等待时间：对应iostat输出的await字段。指磁盘读或写操作等待执行的时间，即在队列中排队的时间。如果 I/O 请求持续超出磁盘处理能力，意味着来不及处理的 I/O 请求不得不在队列中等待较长时间  

**对于磁盘随机读写频繁的业务，比如图片存取、数据库、邮件服务器等，此类业务，IOPS才是关键点。对于顺序读写频繁的业务，需要传输大块数据的，如视频点播、文件同步，关注的是磁盘的吞吐量。如果平均 I/O 数据大小小于 32K，可认为磁盘使用模式是以随机存取为主（关注IOPS）；如果平均每次 I/O 数据大小大于 32K，可认为磁盘使用模式以顺序存取为主（关注吞吐量**）  

对上述论述可以做一个测试：写10MB文件，一个做法是一次写1024B，写10000次。第二个是一次写1B，写10240000次，测试结果如下：  

	[root@master dev]# dd if=/dev/zero of=/dev/null bs=1024 count=10000
	10000+0 records in
	10000+0 records out
	10240000 bytes (10 MB) copied, 0.00982995 s, 1.0 GB/s
	[root@master dev]# dd if=/dev/zero of=/dev/null bs=1 count=10240000
	10240000+0 records in
	10240000+0 records out
	10240000 bytes (10 MB) copied, 7.95257 s, 1.3 MB/s  

从结果看出，写大块数据和写小块数据，吞吐量是不一样的。耗时相差也是很大。在进行磁盘性能分析时要注意下各个指标之间的关系，结合iostat是要注意换算。


[转载](https://www.jianshu.com/p/bc1713ca8d18)